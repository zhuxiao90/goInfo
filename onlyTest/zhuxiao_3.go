/**
 * @Author: zhu
 * @Date: 20-5-15 下午3:04
 */
package main

import (
	"fmt"
	"runtime"
	"sync/atomic"
)

type Person struct {
	Money int64
}
//线程是处理器调度和分配的基本单位，进程则作为资源拥有的基本单位。每个进程是由私有的虚拟地址空间，代码，数据和其他系统资源组成的。
//线程是进程内部的一个执行单元，进程与线程是1：N关系。
//操作系统根据资源访问权限的不同，体系架构可以分为用户空间和内核空间；内核空间主要操作访问cpu资源，i/o资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源
//用户空间就是上层应用程序的固定活动空间，用户空间不可以直接访问基础资源，必须通过系统调用，库函数或shell脚本来调用内核空间提供的资源
//线程模型主要有三个：用户级线程模型，内核级线程模型，两级线程模型。
//内核线程和内核调度实体（KSE）是1:1关系，内核线程的穿件销毁及多个线程之间的上下文切换都是由OS层来做的，多核时并行，当一个线程阻塞后支持另一个线程继续支持，但是创建线程开销大，影响性能
//用户线程与KSE是多对一M：1关系，用户进程的创建，销毁及线程间的协调都是用户自己实现的线程库来负责，对os透明，一个进程所处案件的线程都是与同一个KSE攻台关联。
//缺点：所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，在多处理器环境下这是不能够被接受的，本质上，用户线程只解决了并发问题，但是没有解决并行问题。
// 如果线程因为 I/O 操作陷入了内核态，内核态线程阻塞等待 I/O 数据，则所有的线程都将会被阻塞，用户空间也可以使用非阻塞而 I/O，但是不能避免性能及复杂度问题。
//内核线程解决并行，用户线程解决并发，那么接下来
//-------重点来了，两级线程
//两级线程与KSE是多对多关系（M：N），为一个进程中创建多个KSE，并且线程可以与不同的KSE在运行时进行动态关联，当某个KSE由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其关联的其余用户线程可以重新与其他KSE建立关联关系。
//此模型有时也被称为 混合型线程模型，即用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度。
//go语言的并发调度：MPG模式
//go语言调度器（schedule）主要由：M，G，P,Sched 组成，前三个定义在runtime.h中，Sched定义在proc.c中。
//Sched结构就是调度器，它维护又存储M和G的队列以及调度器的一些状态信息等
//M结构是Machine，系统线程，由操作系统管理，goroutine 就是泡在M之上的，M维护了小对象内存mcache，当前执行的goroutine，随机数发生器等等信息
//P结构式Processor，处理器。主要是用来执行goroutine，它维护了一个goroutine队列，即runqueue。P实现了N：1到M：N
//Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行go代码。
//G就是goroutine，包含了栈，指令指针以及其他队调度goroutine很重要的信息，比如阻塞的channel
//golang的调度理论，只在阻塞的时候抢占，不能被中断，协程有多个point，允许暂停或者重新进入，golang的CSP（Communication Sequential Processes）,强调通过通信来共享内存
//golang还提供了-race参数检测代码中可能存在的竞争 go test -race mycode #对代码进行测试 go run -race mycode.go #编译程序并 运行
//如果没有P，不同的G在不同的M上并发运行时可能都需向系统申请资源（如堆内存），由于资源是全局的，将会由于资源竞争造成很多系统性能损耗
//我们可以在P对象中预先申请一些系统资源（本地资源），G需要的时候先向自己的本地P申请（无需锁保护），如果不够用或没有再向全局申请，而且从全局拿的时候会多拿一部分，以供后面高效的使用
//P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。Go运行时系统通过构造G-P-M对象模型实现了一套用户态的并发调度系统，可以自己管理和调度自己的并发任务，
//所以可以说Go语言原生支持并发。自己实现的调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。
//如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了，但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G。
//然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行
//Go抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占flag，决定是否继续执行，还是让出自己。运行时系统的监控线程会计时并设置抢占flag到运行时间过长的G，然后G在有函数调用的时候会检查该抢占flag，如果已设置就将自己放入全局队列，这样该M上关联的其他G就有机会执行了。
//但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作)，即使抢占flag已经被设置，该G还是将一直霸占着当前M直到执行完自己的任务
func main() {
	runtime.GOMAXPROCS(1)
	p := Person{Money: 100}
	go func() {
		atomic.AddInt64(&p.Money, 1000)
	}()
	atomic.AddInt64(&p.Money, 1000)
	fmt.Printf("Money: %d\n", atomic.LoadInt64(&p.Money))
}
